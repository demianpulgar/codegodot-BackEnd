-- ============================================
-- INSERT DE DATOS INICIALES DE CODIGOS
-- ============================================
-- Ejecutar este script en MySQL para insertar todos los códigos de Godot

USE codegodot_db;

INSERT INTO codigos (titulo, descripcion, categoria, fecha, autor, likes, guardados, codigo) VALUES
-- ============================================
-- MOVIMIENTO
-- ============================================
('Movimiento básico del jugador 2D', 'Sistema simple de movimiento para un personaje 2D. El jugador se mueve izquierda/derecha con las flechas del teclado.\n\n**Cómo implementarlo:**\n1. Crea un nodo CharacterBody2D\n2. Agrega un CollisionShape2D hijo (forma cápsula)\n3. Adjunta este script\n4. Presiona F5 para probar', 'Movimiento', 'Oct 12, 2025', 'CodeGodot', 42, 15, 'extends CharacterBody2D\n\nconst SPEED = 300.0\n\nfunc _physics_process(delta):\n    var direction = Input.get_axis("ui_left", "ui_right")\n    \n    if direction:\n        velocity.x = direction * SPEED\n    else:\n        velocity.x = move_toward(velocity.x, 0, SPEED)\n    \n    move_and_slide()'),

('Salto con gravedad', 'Movimiento 2D con saltos realistas. El jugador salta cuando presiona espacio y cae con gravedad física.\n\n**Cómo implementarlo:**\n1. Crea CharacterBody2D con CollisionShape2D\n2. Crea un nodo StaticBody2D debajo como "suelo"\n3. Adjunta este script al jugador\n4. Ajusta JUMP_VELOCITY si necesitas saltos más altos', 'Movimiento', 'Oct 15, 2025', 'CodeGodot', 58, 28, 'extends CharacterBody2D\n\nconst SPEED = 300.0\nconst JUMP_VELOCITY = -400.0\n\nvar gravity = ProjectSettings.get_setting("physics/2d/default_gravity")\n\nfunc _physics_process(delta):\n    # Aplicar gravedad\n    if not is_on_floor():\n        velocity.y += gravity * delta\n\n    # Saltar si estamos en el suelo\n    if Input.is_action_just_pressed("ui_accept") and is_on_floor():\n        velocity.y = JUMP_VELOCITY\n\n    # Movimiento horizontal\n    var direction = Input.get_axis("ui_left", "ui_right")\n    if direction:\n        velocity.x = direction * SPEED\n    else:\n        velocity.x = move_toward(velocity.x, 0, SPEED)\n\n    move_and_slide()'),

('Dash/Salto corto rápido', 'Mechanic de dash: el jugador se mueve rápidamente en una dirección al presionar una tecla. Perfecto para evasión o ataque ágil.\n\n**Cómo implementarlo:**\n1. Configura el script en tu CharacterBody2D\n2. Cambia DASH_KEY si deseas otra tecla (ej: "shift")\n3. Ajusta DASH_SPEED y DASH_DURATION según necesites', 'Movimiento', 'Oct 18, 2025', 'Elena Wong', 72, 42, 'extends CharacterBody2D\n\nconst SPEED = 300.0\nconst DASH_SPEED = 600.0\nconst DASH_DURATION = 0.3\n\nvar is_dashing = false\nvar dash_timer = 0.0\n\nfunc _physics_process(delta):\n    # Iniciar dash\n    if Input.is_action_just_pressed("ui_cancel") and not is_dashing:\n        is_dashing = true\n        dash_timer = DASH_DURATION\n    \n    # Calcular velocidad\n    var direction = Input.get_axis("ui_left", "ui_right")\n    var current_speed = DASH_SPEED if is_dashing else SPEED\n    \n    if direction:\n        velocity.x = direction * current_speed\n    else:\n        velocity.x = move_toward(velocity.x, 0, current_speed)\n    \n    # Actualizar dash\n    if is_dashing:\n        dash_timer -= delta\n        if dash_timer <= 0:\n            is_dashing = false\n    \n    move_and_slide()'),

('Rotación hacia el ratón', 'El personaje se rota automáticamente para mirar hacia la posición del ratón. Útil para juegos de disparos o RPG.\n\n**Cómo implementarlo:**\n1. Adjunta a un Node2D o CharacterBody2D\n2. El script gira el nodo hacia el cursor automáticamente cada frame\n3. Personaliza la rotación con el código', 'Movimiento', 'Oct 20, 2025', 'Marcus Johnson', 51, 19, 'extends Node2D\n\nfunc _process(delta):\n    # Obtener posición del ratón\n    var mouse_pos = get_global_mouse_position()\n    \n    # Calcular ángulo hacia el ratón\n    var direction = (mouse_pos - global_position).normalized()\n    var angle = direction.angle()\n    \n    # Rotar hacia el ángulo\n    rotation = angle'),

-- ============================================
-- INTERACCIÓN
-- ============================================
('Sistema de interacción simple', 'Permite al jugador interactuar con objetos al presionar E. Ideal para recoger items, hablar con NPCs, abrir puertas.\n\n**Cómo implementarlo:**\n1. Crea un Area2D para el objeto interactuable\n2. Agrega un CollisionShape2D hijo\n3. Adjunta este script al Area2D\n4. Conecta la señal "interacted" a lo que desees hacer', 'Interacción', 'Oct 22, 2025', 'CodeGodot', 64, 31, 'extends Area2D\n\nsignal interacted\n\nfunc _ready():\n    area_entered.connect(_on_area_entered)\n    area_exited.connect(_on_area_exited)\n\nfunc _process(delta):\n    if overlaps_area(get_tree().get_first_child_in_group("player")) and Input.is_action_just_pressed("interact"):\n        interact()\n\nfunc interact():\n    print("Interactuado con: ", name)\n    emit_signal("interacted")\n\nfunc _on_area_entered(area):\n    if area.is_in_group("player"):\n        print("Presiona E para interactuar")\n\nfunc _on_area_exited(area):\n    if area.is_in_group("player"):\n        print("Saliste del área")'),

('Recoger items', 'Script para items que el jugador puede recoger. Suma puntos o agrega al inventario cuando se toca.\n\n**Cómo implementarlo:**\n1. Crea un Area2D para el item\n2. Adjunta este script\n3. Personaliza POINTS_VALUE según el item\n4. Conecta a tu sistema de puntuación', 'Interacción', 'Oct 25, 2025', 'Sarah Chen', 48, 22, 'extends Area2D\n\nconst POINTS_VALUE = 10\n\nfunc _ready():\n    area_entered.connect(_on_area_entered)\n\nfunc _on_area_entered(area):\n    if area.is_in_group("player"):\n        print("Item recogido! +", POINTS_VALUE, " puntos")\n        # Aquí agrega puntuación o inventario\n        queue_free()  # Elimina el item'),

('Diálogo simple con NPC', 'Sistema básico de diálogo. Muestra un panel de texto cuando hablas con un NPC. Presiona espacio para avanzar.\n\n**Cómo implementarlo:**\n1. Crea un CanvasLayer para el panel\n2. Agrega un Label hijo para el texto\n3. Adjunta este script al NPC (Area2D)\n4. Rellena el array "dialogues" con tu texto', 'Interacción', 'Oct 28, 2025', 'CodeGodot', 76, 45, 'extends Area2D\n\nvar dialogues = [\n    "Hola, bienvenido a mi tienda!",\n    "Tengo muchos items interesantes.",\n    "¿Quieres comprar algo?"\n]\n\nvar current_dialogue = 0\nvar is_talking = false\n\nfunc _ready():\n    area_entered.connect(_on_area_entered)\n\nfunc _process(delta):\n    if is_talking and Input.is_action_just_pressed("ui_accept"):\n        current_dialogue += 1\n        if current_dialogue >= dialogues.size():\n            end_dialogue()\n        else:\n            show_dialogue()\n\nfunc _on_area_entered(area):\n    if area.is_in_group("player"):\n        start_dialogue()\n\nfunc start_dialogue():\n    is_talking = true\n    current_dialogue = 0\n    show_dialogue()\n\nfunc show_dialogue():\n    print(dialogues[current_dialogue])\n\nfunc end_dialogue():\n    is_talking = false\n    current_dialogue = 0\n    print("Diálogo terminado")'),

-- ============================================
-- COMBATE
-- ============================================
('Sistema de vida/salud básico', 'Gestión de vida del jugador y de enemigos. Toma daño, cura, muere cuando la salud llega a 0.\n\n**Cómo implementarlo:**\n1. Agrega este script a tu personaje\n2. Conecta signals de daño desde enemigos\n3. Crea una UI que muestre la barra de vida', 'Combate', 'Nov 1, 2025', 'CodeGodot', 85, 52, 'extends Node2D\n\nsignal health_changed\nsignal died\n\nvar max_health = 100\nvar current_health = 100\n\nfunc _ready():\n    emit_signal("health_changed", current_health, max_health)\n\nfunc take_damage(damage: int):\n    current_health -= damage\n    print("Daño recibido: ", damage, " | Salud: ", current_health)\n    emit_signal("health_changed", current_health, max_health)\n    \n    if current_health <= 0:\n        die()\n\nfunc heal(amount: int):\n    current_health = min(current_health + amount, max_health)\n    emit_signal("health_changed", current_health, max_health)\n\nfunc die():\n    print("El jugador ha muerto!")\n    emit_signal("died")\n    queue_free()'),

('Disparar proyectiles', 'Script que permite disparar balas en la dirección del ratón. Perfecto para juegos de disparos.\n\n**Cómo implementarlo:**\n1. Crea una escena "Bullet" con Area2D y CollisionShape2D\n2. Agrega este script al jugador\n3. Guarda la escena de bala en res://Bullet.tscn\n4. Presiona clic izquierdo para disparar', 'Combate', 'Nov 4, 2025', 'Lucas Patel', 92, 61, 'extends Node2D\n\nvar bullet_scene = preload("res://Bullet.tscn")\nconst BULLET_SPEED = 500.0\n\nfunc _process(delta):\n    if Input.is_action_just_pressed("attack"):\n        shoot()\n\nfunc shoot():\n    var bullet = bullet_scene.instantiate()\n    get_parent().add_child(bullet)\n    \n    bullet.global_position = global_position\n    var direction = (get_global_mouse_position() - global_position).normalized()\n    bullet.velocity = direction * BULLET_SPEED\n    \n    print("¡Disparo!")'),

('Detección de colisión para daño', 'Causa daño cuando una bala o ataque golpea a un enemigo. Usa áreas de colisión para detectar impactos.\n\n**Cómo implementarlo:**\n1. Adjunta a un proyectil o arma\n2. Conecta la señal area_entered\n3. Verifica si el área golpeó un enemigo\n4. Llama a take_damage() del enemigo', 'Combate', 'Nov 7, 2025', 'CodeGodot', 77, 38, 'extends Area2D\n\nvar damage = 10\nvar hit_targets = []  # Evita daño múltiple al mismo target\n\nfunc _ready():\n    area_entered.connect(_on_area_entered)\n\nfunc _on_area_entered(area):\n    if area.is_in_group("enemy") and area not in hit_targets:\n        hit_targets.append(area)\n        area.take_damage(damage)\n        print("Golpe al enemigo!")\n        queue_free()  # Elimina el proyectil'),

-- ============================================
-- ANIMACIONES
-- ============================================
('Animación de caminar', 'Anima el personaje mientras camina con AnimatedSprite2D. La animación cambia según la dirección.\n\n**Cómo implementarlo:**\n1. Crea un AnimatedSprite2D hijo en tu personaje\n2. Crea animaciones "walk_left" y "walk_right" en el AnimatedSprite\n3. Adjunta este script\n4. Personaliza la velocidad de animación si necesitas', 'Animación', 'Nov 10, 2025', 'CodeGodot', 69, 33, 'extends CharacterBody2D\n\nconst SPEED = 300.0\n@onready var animated_sprite = $AnimatedSprite2D\n\nfunc _physics_process(delta):\n    var direction = Input.get_axis("ui_left", "ui_right")\n    \n    if direction != 0:\n        velocity.x = direction * SPEED\n        # Cambiar animación según dirección\n        animated_sprite.animation = "walk_right" if direction > 0 else "walk_left"\n        animated_sprite.play()\n    else:\n        velocity.x = move_toward(velocity.x, 0, SPEED)\n        animated_sprite.stop()\n    \n    move_and_slide()'),

('Tween - Animación suave', 'Usa Tween para animar objetos suavemente (mover, rotar, escalar). Muy útil para UI y efectos visuales.\n\n**Cómo implementarlo:**\n1. Adjunta a cualquier Node2D o Control\n2. El script anima el movimiento automáticamente\n3. Personaliza duration y el destino (target_pos)', 'Animación', 'Nov 13, 2025', 'Sophie Laurent', 81, 47, 'extends Node2D\n\nvar target_pos = Vector2(400, 300)\nvar duration = 2.0\n\nfunc _ready():\n    var tween = create_tween()\n    tween.set_trans(Tween.TRANS_QUAD)\n    tween.set_ease(Tween.EASE_OUT)\n    tween.tween_property(self, "position", target_pos, duration)\n\nfunc animate_scale():\n    var tween = create_tween()\n    tween.tween_property(self, "scale", Vector2(1.5, 1.5), 0.5)\n    tween.tween_property(self, "scale", Vector2(1.0, 1.0), 0.5)'),

-- ============================================
-- FÍSICA
-- ============================================
('Rebote elástico', 'El objeto rebota cuando golpea paredes o suelo. Perfecto para bolas, piedras o efectos de explosión.\n\n**Cómo implementarlo:**\n1. Crea un RigidBody2D\n2. Agrega un CollisionShape2D\n3. Adjunta este script\n4. Personaliza ELASTICITY para más/menos rebote', 'Física', 'Nov 16, 2025', 'CodeGodot', 56, 24, 'extends RigidBody2D\n\nconst ELASTICITY = 0.7\nconst FRICTION = 0.1\n\nfunc _physics_process(delta):\n    # Detectar colisión\n    for i in get_slide_collision_count():\n        var collision = get_slide_collision(i)\n        var normal = collision.get_normal()\n        \n        # Invertir velocidad en dirección de la normal\n        velocity = velocity.bounce(normal) * ELASTICITY\n    \n    move_and_slide()'),

('Atracción/Repulsión', 'Los objetos se atraen o repelen uno del otro. Crea órbitas, campos de fuerza o imanes.\n\n**Cómo implementarlo:**\n1. Coloca dos Node2D en la escena\n2. Adjunta este script a uno de ellos\n3. Asigna la referencia al otro en el Inspector\n4. Personaliza FORCE_STRENGTH para intensidad', 'Física', 'Nov 19, 2025', 'David Kim', 43, 18, 'extends Node2D\n\n@export var target: Node2D\n@export var FORCE_STRENGTH = 500.0\n@export var is_repel = false  # true = repele, false = atrae\n\nfunc _process(delta):\n    if not target:\n        return\n    \n    var direction = (target.global_position - global_position).normalized()\n    if is_repel:\n        direction = -direction\n    \n    global_position += direction * FORCE_STRENGTH * delta'),

-- ============================================
-- ENTRADA/INPUT
-- ============================================
('Soporte para gamepad/joystick', 'Detecta entrada de gamepad (botones, joysticks) para controles completos de consola.\n\n**Cómo implementarlo:**\n1. Adjunta a tu jugador\n2. Conecta un gamepad al PC\n3. Los botones ya estarán mapeados en Input Map\n4. Personaliza según tus necesidades', 'Entrada', 'Nov 22, 2025', 'CodeGodot', 67, 36, 'extends CharacterBody2D\n\nconst SPEED = 300.0\n\nfunc _physics_process(delta):\n    # Joystick izquierdo\n    var gamepad_input = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")\n    \n    if gamepad_input.length() > 0:\n        velocity = gamepad_input.normalized() * SPEED\n    else:\n        velocity = Vector2.ZERO\n    \n    # Botón A del gamepad\n    if Input.is_action_just_pressed("ui_accept"):\n        print("Botón A presionado")\n    \n    move_and_slide()'),

('Entrada de ratón - Click para mover', 'El personaje se mueve al lugar donde haces clic. Estilo point-and-click clásico.\n\n**Cómo implementarlo:**\n1. Adjunta a tu personaje (CharacterBody2D)\n2. Haz clic en la escena para mover\n3. El personaje caminará hacia el punto automáticamente', 'Entrada', 'Nov 25, 2025', 'Anna Rodriguez', 74, 41, 'extends CharacterBody2D\n\nconst SPEED = 200.0\nvar target_position = null\n\nfunc _input(event):\n    if event is InputEventMouseButton and event.pressed:\n        target_position = get_global_mouse_position()\n\nfunc _physics_process(delta):\n    if target_position:\n        var direction = (target_position - global_position).normalized()\n        \n        if global_position.distance_to(target_position) > 10:\n            velocity = direction * SPEED\n        else:\n            velocity = Vector2.ZERO\n            target_position = null\n    \n    move_and_slide()'),

-- ============================================
-- UI
-- ============================================
('Barra de vida visual', 'UI que muestra la salud como barra. Se actualiza cuando tomas daño o te curas.\n\n**Cómo implementarlo:**\n1. Crea un Control con un ColorRect hijo para la barra\n2. Adjunta este script\n3. Conecta con tu sistema de vida\n4. Personaliza los colores (rojo para bajo, verde para alto)', 'UI', 'Nov 28, 2025', 'CodeGodot', 89, 58, 'extends Control\n\n@onready var health_bar = $ColorRect\n\nvar max_health = 100\nvar current_health = 100\n\nfunc _ready():\n    update_bar()\n\nfunc take_damage(damage):\n    current_health -= damage\n    update_bar()\n\nfunc update_bar():\n    var percentage = current_health / float(max_health)\n    health_bar.size.x = 200 * percentage  # Ajusta 200 al ancho deseado\n    \n    # Cambiar color según salud\n    if percentage > 0.5:\n        health_bar.color = Color.GREEN\n    elif percentage > 0.25:\n        health_bar.color = Color.YELLOW\n    else:\n        health_bar.color = Color.RED'),

('Menú pausa simple', 'Pausa el juego cuando presionas ESC. Muestra un panel con botones de reanudar y salir.\n\n**Cómo implementarlo:**\n1. Crea un CanvasLayer para el menú\n2. Agrega botones y etiquetas\n3. Adjunta este script\n4. El juego se pausa automáticamente', 'UI', 'Dic 1, 2025', 'James Wilson', 102, 73, 'extends CanvasLayer\n\nvar is_paused = false\n\nfunc _ready():\n    visible = false\n\nfunc _process(delta):\n    if Input.is_action_just_pressed("ui_cancel"):\n        toggle_pause()\n\nfunc toggle_pause():\n    is_paused = !is_paused\n    visible = is_paused\n    get_tree().paused = is_paused\n    \n    print("Paused: ", is_paused)\n\nfunc _on_resume_pressed():\n    toggle_pause()\n\nfunc _on_quit_pressed():\n    get_tree().quit()'),

('Sistema de puntuación', 'Gestiona puntos del jugador. Suma puntos, muestra en pantalla, guarda máximo.\n\n**Cómo implementarlo:**\n1. Crea un Label en la UI\n2. Adjunta este script a un Node de control general\n3. Conecta signals para sumar puntos\n4. El Label se actualiza automáticamente', 'UI', 'Dic 4, 2025', 'CodeGodot', 71, 44, 'extends Node\n\nvar current_score = 0\nvar high_score = 0\nvar score_label: Label\n\nfunc _ready():\n    score_label = get_node("CanvasLayer/ScoreLabel")  # Ajusta la ruta\n    load_high_score()\n    update_display()\n\nfunc add_score(amount: int):\n    current_score += amount\n    if current_score > high_score:\n        high_score = current_score\n        save_high_score()\n    update_display()\n\nfunc update_display():\n    score_label.text = "Score: " + str(current_score)\n\nfunc save_high_score():\n    print("Nuevo máximo: ", high_score)\n\nfunc load_high_score():\n    print("Máximo anterior: ", high_score)'),

('Fade in/out de pantalla', 'Oscurece la pantalla gradualmente (fade out) o la aclara (fade in). Perfecto para transiciones entre niveles.\n\n**Cómo implementarlo:**\n1. Crea un CanvasLayer con un ColorRect negro\n2. Adjunta este script\n3. Llama a fade_out() o fade_in() desde otros scripts\n4. Usa para transiciones de niveles', 'UI', 'Dic 7, 2025', 'Rosa García', 58, 31, 'extends CanvasLayer\n\n@onready var fade_rect = $ColorRect  # Debe ser ColorRect negro\n\nfunc fade_out(duration = 1.0):\n    var tween = create_tween()\n    tween.tween_property(fade_rect, "modulate:a", 1.0, duration)\n\nfunc fade_in(duration = 1.0):\n    var tween = create_tween()\n    tween.tween_property(fade_rect, "modulate:a", 0.0, duration)\n\nfunc change_scene(scene_path: String, fade_duration = 1.0):\n    fade_out(fade_duration)\n    await get_tree().create_timer(fade_duration).timeout\n    get_tree().change_scene_to_file(scene_path)'),

-- ============================================
-- SEÑALES
-- ============================================
('Sistema de señales básico', 'Usa señales para comunicar eventos entre nodos sin acoplamiento. Un botón emite una señal, otros nodos la escuchan.\n\n**Cómo implementarlo:**\n1. Define una signal en el script del emisor\n2. Emite la señal con emit_signal()\n3. Otros scripts se conectan con .connect()\n4. Responden cuando se emite', 'Señales', 'Dic 10, 2025', 'CodeGodot', 64, 37, '# Script del emisor (Botón)\nextends Button\n\nsignal button_pressed\n\nfunc _ready():\n    pressed.connect(_on_pressed)\n\nfunc _on_pressed():\n    emit_signal("button_pressed")\n    print("Botón presionado!")\n\n# Script del receptor (otro nodo)\nextends Node\n\nfunc _ready():\n    var button = get_node("Button")\n    button.button_pressed.connect(_on_button_pressed)\n\nfunc _on_button_pressed():\n    print("¡Recibí la señal del botón!")'),

('Eventos globales con Autoload', 'Crea un singleton global que emite eventos para toda la aplicación. Útil para cambios de nivel, música, efectos globales.\n\n**Cómo implementarlo:**\n1. Crea un script nuevo (EventManager.gd)\n2. Añádelo como Autoload en Project Settings\n3. Otros scripts emiten con EventManager.level_complete.emit()\n4. Conecta desde cualquier parte del juego', 'Señales', 'Dic 13, 2025', 'Kevin Lee', 77, 49, '# EventManager.gd - Añadido como Autoload\nextends Node\n\nsignal level_complete\nsignal player_died\nsignal enemy_spawned\n\nfunc emit_level_complete(level_num: int):\n    emit_signal("level_complete", level_num)\n\nfunc emit_player_died():\n    emit_signal("player_died")\n\n# En otros scripts:\n# EventManager.level_complete.connect(_on_level_complete)\n# func _on_level_complete(level):\n#     print("¡Nivel ", level, " completado!")'),

-- ============================================
-- EFECTOS
-- ============================================
('Partículas de explosión', 'Crea un efecto de partículas cuando algo explota. Usa GPUParticles2D para rendimiento óptimo.\n\n**Cómo implementarlo:**\n1. Crea un nodo GPUParticles2D\n2. Configura el material y las propiedades de emisión\n3. Adjunta este script\n4. Llama a explode() cuando necesites el efecto', 'Efectos', 'Dic 16, 2025', 'CodeGodot', 73, 45, 'extends GPUParticles2D\n\nfunc _ready():\n    emitting = false\n\nfunc explode():\n    emitting = true\n    # Detener después de que terminen las partículas\n    await get_tree().create_timer(lifetime).timeout\n    queue_free()\n\n# Llamar desde otro script:\n# var explosion = explosion_scene.instantiate()\n# get_parent().add_child(explosion)\n# explosion.global_position = your_position\n# explosion.explode()'),

('Sonidos de efectos (SFX)', 'Reproduce sonidos cuando ocurren eventos (salto, golpe, recoger item). Maneja volumen y reproducción.\n\n**Cómo implementarlo:**\n1. Crea un nodo AudioStreamPlayer\n2. Carga un archivo .ogg o .mp3\n3. Adjunta este script\n4. Llama a play_sound() desde eventos', 'Efectos', 'Dic 19, 2025', 'Lisa Park', 82, 52, 'extends AudioStreamPlayer\n\n@export var jump_sound: AudioStream\n@export var hit_sound: AudioStream\n@export var pickup_sound: AudioStream\n\nfunc play_jump():\n    play_sound(jump_sound)\n\nfunc play_hit():\n    play_sound(hit_sound)\n\nfunc play_pickup():\n    play_sound(pickup_sound)\n\nfunc play_sound(sound: AudioStream):\n    if sound:\n        stream = sound\n        play()\n    else:\n        print("Sound not assigned")'),

('Cámara que sigue al jugador', 'La cámara sigue al personaje del jugador en todo momento. Mantiene el juego centrado y visible.\n\n**Cómo implementarlo:**\n1. Crea un nodo Camera2D hijo del jugador\n2. O adjunta este script a una Camera2D\n3. Personaliza SMOOTHING para velocidad de seguimiento\n4. Agrega límites de cámara si necesitas', 'Cámara', 'Dic 22, 2025', 'CodeGodot', 96, 61, 'extends Camera2D\n\n@export var target: Node2D\n@export var smoothing = 0.1\n@export var offset = Vector2.ZERO\n\nvar limit_left = -100000\nvar limit_right = 100000\nvar limit_top = -100000\nvar limit_bottom = 100000\n\nfunc _process(delta):\n    if not target:\n        return\n    \n    var desired_pos = target.global_position + offset\n    global_position = global_position.lerp(desired_pos, smoothing)\n    \n    # Aplicar límites\n    global_position.x = clamp(global_position.x, limit_left, limit_right)\n    global_position.y = clamp(global_position.y, limit_top, limit_bottom)');
